{"modules": {"reduce_colors": {"inputs": ["INPUT0"], "params": [{"name": "data", "type": null, "info": null}, {"name": "count", "type": "int", "info": {"start": 1, "end": 256, "default": 16}}], "src": "uniform sampler2D STAGE_data; /// custom\nuniform int STAGE_count; /// { \"start\": 1, \"end\": 256, \"default\": 16 }\n\nvec4 STAGE(vec2 coords) {\n    vec3 color = INPUT0(coords).rgb;\n    vec3 closest_color = vec3(0.);\n    float dist = -1.;\n    for (int i = 0; i < STAGE_count; i++) {\n        vec3 candidate = texelFetch(STAGE_data, ivec2(i, 0), 0).rgb;\n        vec3 dists = abs(candidate - color);\n        float curr_dist = dists.r + dists.g + dists.b;\n        if (dist < 0. || curr_dist < dist) {\n            dist = curr_dist;\n            closest_color = candidate;\n        }\n    }\n\n    return vec4(closest_color, 1.);\n}\n"}, "noise": {"inputs": [], "params": [{"name": "r", "type": "float", "info": {"start": 0, "end": 10000, "default": 0}}, {"name": "g", "type": "float", "info": {"start": 0, "end": 10000, "default": 0}}, {"name": "b", "type": "float", "info": {"start": 0, "end": 10000, "default": 0}}], "src": "uniform float STAGE_r; /// { \"start\": 0, \"end\": 10000, \"default\": 0 }\nuniform float STAGE_g; /// { \"start\": 0, \"end\": 10000, \"default\": 0 }\nuniform float STAGE_b; /// { \"start\": 0, \"end\": 10000, \"default\": 0 }\n\n// 2D Random\nfloat STAGE_random(in vec2 st, float noise_param) {\n  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * noise_param);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat STAGE_noise_1d(float noise_param, vec2 coords) {\n  vec2 st = coords.xy / u_dimensions;\n  st *= 5.;\n\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  // Four corners in 2D of a tile\n  float a = STAGE_random(i, noise_param);\n  float b = STAGE_random(i + vec2(1.0, 0.0), noise_param);\n  float c = STAGE_random(i + vec2(0.0, 1.0), noise_param);\n  float d = STAGE_random(i + vec2(1.0, 1.0), noise_param);\n\n  // Smooth Interpolation\n\n  // Cubic Hermine Curve.  Same as SmoothStep()\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  // u = smoothstep(0.,1.,f);\n\n  // Mix 4 coorners percentages\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nvec4 STAGE(vec2 coords) {\n  float r = STAGE_noise_1d(STAGE_r, coords);\n  float g = STAGE_noise_1d(STAGE_g, coords);\n  float b = STAGE_noise_1d(STAGE_b, coords);\n  return vec4(r, g, b, 1.);\n}\n"}, "blur": {"inputs": ["INPUT0"], "params": [{"name": "stride_x", "type": "int", "info": {"start": 1, "end": 100, "default": 1}}, {"name": "stride_y", "type": "int", "info": {"start": 1, "end": 100, "default": 1}}], "src": "uniform int STAGE_stride_x; /// { \"start\": 1, \"end\": 100, \"default\": 1 }\nuniform int STAGE_stride_y; /// { \"start\": 1, \"end\": 100, \"default\": 1 }\n\nvec4 STAGE(vec2 coords) {\n    vec3 color = vec3(0);\n    int stride_x = 2 * STAGE_stride_x - 1;\n    int stride_y = 2 * STAGE_stride_y - 1;\n\n    color += INPUT0(coords + vec2(-1, -1)).rgb * 0.045 ;\n    color += INPUT0(coords + vec2(0, -1)).rgb * 0.122 ;\n    color += INPUT0(coords + vec2(1, -1)).rgb * 0.045 ;\n\n    color += INPUT0(coords + vec2(-1, 0)).rgb * 0.122 ;\n    color += INPUT0(coords + vec2(0, 0)).rgb * 0.332 ;\n    color += INPUT0(coords + vec2(1, 0)).rgb * 0.122 ;\n\n    color += INPUT0(coords + vec2(-1, 1)).rgb * 0.045 ;\n    color += INPUT0(coords + vec2(0, 1)).rgb * 0.122 ;\n    color += INPUT0(coords + vec2(1, 1)).rgb * 0.045 ;\n\n    return vec4(color, 1.);\n}\n"}, "oscillator": {"inputs": [], "params": [{"name": "osc_f", "type": "vec2", "info": {"start": [0, 0], "end": [1, 1], "default": [0.25, 0], "names": ["x", "y"]}}, {"name": "osc_c", "type": "float", "info": {"start": 0, "end": 6.283185307179586, "default": 0}}, {"name": "osc_color", "type": "vec3", "info": {"start": [0, 0, 0], "end": [1, 1, 1], "default": [1, 0, 0], "names": ["r", "g", "b"]}}], "src": "uniform vec2 STAGE_osc_f; /// { \"start\": [0, 0], \"end\": [1, 1], \"default\": [0.25, 0], \"names\": [\"x\", \"y\"] }\nuniform float STAGE_osc_c; /// { \"start\": 0, \"end\": \"2 * math.pi\", \"default\": 0 }\nuniform vec3 STAGE_osc_color; /// { \"start\": [0, 0, 0], \"end\": [1, 1, 1], \"default\": [1, 0, 0], \"names\": [\"r\", \"g\", \"b\"] }\n\nvec4 STAGE(vec2 coords) {\n    vec4 res = vec4(0.);\n    res.xyz += sin(dot(STAGE_osc_f, coords) + STAGE_osc_c) * STAGE_osc_color;\n    res.a = 1.;\n    return res;\n}\n"}, "recolor": {"inputs": ["INPUT0"], "params": [{"name": "new_r", "type": "vec3", "info": {"start": [0, 0, 0], "end": [1, 1, 1], "default": [1, 0, 0], "names": ["r", "g", "b"]}}, {"name": "new_g", "type": "vec3", "info": {"start": [0, 0, 0], "end": [1, 1, 1], "default": [0, 1, 0], "names": ["r", "g", "b"]}}, {"name": "new_b", "type": "vec3", "info": {"start": [0, 0, 0], "end": [1, 1, 1], "default": [0, 0, 1], "names": ["r", "g", "b"]}}], "src": "uniform vec3 STAGE_new_r; /// { \"start\": [0, 0, 0], \"end\": [1, 1, 1], \"default\": [1, 0, 0], \"names\": [\"r\", \"g\", \"b\"] }\nuniform vec3 STAGE_new_g; /// { \"start\": [0, 0, 0], \"end\": [1, 1, 1], \"default\": [0, 1, 0], \"names\": [\"r\", \"g\", \"b\"] }\nuniform vec3 STAGE_new_b; /// { \"start\": [0, 0, 0], \"end\": [1, 1, 1], \"default\": [0, 0, 1], \"names\": [\"r\", \"g\", \"b\"] }\n\nvec4 STAGE(vec2 coords) {\n    vec3 color = INPUT0(coords).rgb;\n    return vec4(\n        color.r * STAGE_new_r +\n        color.g * STAGE_new_g +\n        color.b * STAGE_new_b, 1.);\n}\n"}, "pixelate": {"inputs": ["INPUT0"], "params": [{"name": "factor", "type": "int", "info": {"start": 0, "end": 500, "default": 10}}], "src": "uniform int STAGE_factor; /// { \"start\": 0, \"end\": 500, \"default\": 10 }\n\nvec4 STAGE(vec2 coords) {\n    float f = float(STAGE_factor);\n    coords = floor(coords / f) * f;\n    vec3 color = vec3(0);\n    float samples = 4.;\n    color += INPUT0(coords + vec2(0, 0)).xyz / samples;\n    color += INPUT0(coords + vec2(0, STAGE_factor)).xyz / samples;\n    color += INPUT0(coords + vec2(STAGE_factor, 0)).xyz / samples;\n    color += INPUT0(coords + vec2(STAGE_factor, STAGE_factor)).xyz / samples;\n    return vec4(color, 1.);\n}\n"}, "invert_color": {"inputs": ["INPUT0"], "params": [], "src": "vec4 STAGE(vec2 coords) {\n    return vec4(1. - INPUT0(coords).rgb, 1.);\n}\n"}, "mix": {"inputs": ["INPUT0", "INPUT1"], "params": [{"name": "input0_strength", "type": "float", "info": {"start": 0, "end": 1, "default": 1}}, {"name": "input1_strength", "type": "float", "info": {"start": 0, "end": 1, "default": 1}}], "src": "uniform float STAGE_input0_strength; /// { \"start\": 0, \"end\": 1, \"default\": 1 }\nuniform float STAGE_input1_strength; /// { \"start\": 0, \"end\": 1, \"default\": 1 }\n\nvec4 STAGE(vec2 coords) {\n    vec3 color = STAGE_input0_strength * INPUT0(coords).rgb +\n      STAGE_input1_strength * INPUT1(coords).rgb;\n    return vec4(color, 1.);\n}\n"}, "tile": {"inputs": ["INPUT0"], "params": [{"name": "x", "type": "int", "info": {"start": 1, "end": 100, "default": 2}}, {"name": "y", "type": "int", "info": {"start": 1, "end": 100, "default": 2}}], "src": "uniform int STAGE_x; /// { \"start\": 1, \"end\": 100, \"default\": 2 }\nuniform int STAGE_y; /// { \"start\": 1, \"end\": 100, \"default\": 2 }\n\nvec4 STAGE(vec2 coords) {\n    float tile_x_size = u_dimensions.x / float(STAGE_x);\n    float tile_y_size = u_dimensions.y / float(STAGE_y);\n\n    coords.x = mod(coords.x, tile_x_size) * float(STAGE_x);\n    coords.y = mod(coords.y, tile_y_size) * float(STAGE_y);\n    // vec2 c = coords / u_dimensions;\n\n    return INPUT0(coords);\n}\n"}, "polygon": {"inputs": [], "params": [{"name": "color", "type": "vec3", "info": {"start": [0, 0, 0], "end": [1, 1, 1], "default": [1, 0, 0], "names": ["r", "g", "b"]}}, {"name": "n", "type": "int", "info": {"start": 3, "end": 100, "default": 4}}, {"name": "r", "type": "float", "info": {"start": 0, "end": 1, "default": 0.49999}}, {"name": "thickness", "type": "float", "info": {"start": 0, "end": 1, "default": 0.025}}, {"name": "smooth_edges", "type": "bool", "info": {"default": true}}, {"name": "fill", "type": "bool", "info": {"default": false}}, {"name": "destructive", "type": "bool", "info": {"default": false}}], "src": "uniform vec3 STAGE_color; /// { \"start\": [0, 0, 0], \"end\": [1, 1, 1], \"default\": [1, 0, 0], \"names\": [\"r\", \"g\", \"b\"] }\nuniform int STAGE_n; /// { \"start\": 3, \"end\": 100, \"default\": 4 }\nuniform float STAGE_r; /// { \"start\": 0, \"end\": 1, \"default\": 0.49999 }\nuniform float STAGE_thickness; /// { \"start\": 0, \"end\": 1, \"default\": 0.025 }\nuniform bool STAGE_smooth_edges; /// { \"default\": true }\nuniform bool STAGE_fill; /// { \"default\": false }\nuniform bool STAGE_destructive; /// { \"default\": false }\n\nvec4 STAGE(vec2 coords) {\n    vec4 color_out;\n    color_out.a = 1.;\n\n    vec2 c = coords / u_dimensions;\n    c = 2. * c - 1.;\n\n    float r = length(c);\n    float theta = atan(c.y, c.x);\n    if (theta < 0.)\n        theta += 2. * PI;\n\n    float angle = 2. * PI / float(STAGE_n);\n    float lower = floor(theta / angle) * angle;\n    float higher = ceil(theta / angle) * angle;\n\n    vec2 lower_c = STAGE_r * vec2(cos(lower), sin(lower));\n    vec2 higher_c = STAGE_r * vec2(cos(higher), sin(higher));\n    // if (length(lower_c - c) < 0.1)\n    //     color_out.rgb = vec3(1.);\n    // if (length(higher_c - c) < 0.1)\n    //     color_out.rgb = vec3(1.);\n\n    // return;\n    // a + (b - a) * t = r' * (cos x, sin x)\n    // a.x + (b.x - a.x) * t = r' * cos x\n    // a.y + (b.y - a.y) * t = r' * sin x\n    //\n    // t = (r' * cos x - a.x) / (b.x - a.x)\n    // r' * sin x = (a.y + (r' * cos x - a.x) (b.y - a.y) / (b.x - a.x))\n    // r' * sin x - (r' * cos x) (b.y - a.y) / (b.x - a.x) = a.y - a.x * (b.y - a.y) / (b.x - a.x)\n    // r' * (sin x - (cos x - a.x) (b.y - a.y) / (b.x - a.x) = a.y - a.x * (b.y - a.y) / (b.x - a.x)\n    // where a = lower_c, b = higher_c, x = theta, r' = radius along pg edge\n\n    vec2 s = higher_c - lower_c;\n    float lhs = 1. - (cos(theta) * s.y / (sin(theta) * s.x));\n    float rhs = (lower_c.y * s.x - lower_c.x * s.y) / (sin(theta) * s.x);\n    // float lhs = (\n    //     sin(theta) - (cos(theta) - lower_c.x) * (\n    //         (higher_c.y - lower_c.y) / (higher_c.x - lower_c.x)\n    //     ));\n\n    // float rhs = (\n    //     lower_c.y - lower_c.x * (\n    //         (higher_c.y - lower_c.y) / (higher_c.x - lower_c.x)\n    //     ));\n    float pg_r = rhs / lhs;\n\n    // float base = length(higher_c - lower_c);\n    // float h = sqrt(STAGE_r * STAGE_r - base * base);\n    // float pg_r = 0.;\n    // float avg = (lower + higher) / 2.;\n    // if (theta < avg)\n    //     pg_r = mix(STAGE_r, h, (theta - lower) / (avg - lower));\n    // else\n    //     pg_r = mix(h, STAGE_r, (theta - avg) / (avg - lower));\n\n\n    if (abs(r - pg_r) < STAGE_thickness || (STAGE_fill && r < pg_r)) {\n        float factor = 1.;\n        if (STAGE_smooth_edges && (!STAGE_fill || r >= pg_r)) {\n            factor = 1. - abs(r - pg_r) / STAGE_thickness;\n        }\n\n        if (STAGE_destructive && factor > 0.)\n            color_out.rgb = factor * STAGE_color;\n        else\n            color_out.rgb += factor * STAGE_color;\n    }\n\n    return color_out;\n}\n"}, "brightness": {"inputs": ["INPUT0"], "params": [{"name": "strength", "type": "float", "info": {"start": 0, "end": 2, "default": 1}}], "src": "uniform float STAGE_strength; /// { \"start\": 0, \"end\": 2, \"default\": 1 }\n\nvec4 STAGE(vec2 coords) {\n    return STAGE_strength * INPUT0(coords);\n}\n"}, "mirror": {"inputs": ["INPUT0"], "params": [{"name": "reflect_theta", "type": "float", "info": {"start": 0, "end": 6.283185307179586, "default": 1.5707963267948966}}, {"name": "reflect_y", "type": "float", "info": {"start": -1, "end": 1, "default": 0}}, {"name": "reflect_x", "type": "float", "info": {"start": -1, "end": 1, "default": 0}}], "src": "uniform float STAGE_reflect_theta; /// { \"start\": 0, \"end\": \"2 * math.pi\", \"default\": \"math.pi / 2\" }\nuniform float STAGE_reflect_y; /// { \"start\": -1, \"end\": 1, \"default\": 0 }\nuniform float STAGE_reflect_x; /// { \"start\": -1, \"end\": 1, \"default\": 0 }\n\nvec4 STAGE(vec2 coords) {\n    vec2 c = coords / u_dimensions;\n    c = 2. * c - 1.;\n    c.y -= STAGE_reflect_y;\n    c.x -= STAGE_reflect_x;\n\n    float r = length(c);\n    float theta = atan(c.y, c.x);\n    float pos_theta = theta;\n    if (pos_theta < 0.)\n        pos_theta = 2. * PI + pos_theta;\n\n    vec3 color = vec3(0.);\n\n    if (pos_theta > (STAGE_reflect_theta - PI) &&\n            (pos_theta < STAGE_reflect_theta ||\n             pos_theta > (STAGE_reflect_theta + PI))) {\n        color = INPUT0(coords).xyz;\n    } else {\n        theta = -(theta - STAGE_reflect_theta) + STAGE_reflect_theta;\n\n        c = r * vec2(cos(theta), sin(theta));\n\n        c.y += STAGE_reflect_y;\n        c.x += STAGE_reflect_x;\n        c = (c + 1.) / 2.;\n        c *= u_dimensions;\n        color = INPUT0(c).xyz;\n    }\n\n    return vec4(color, 1.);\n}\n"}, "offset": {"inputs": ["INPUT0"], "params": [{"name": "offsets_x", "type": "vec3", "info": {"start": [-1, -1, -1], "end": [1, 1, 1], "default": [0, 0, 0], "names": ["r", "g", "b"]}}, {"name": "offsets_y", "type": "vec3", "info": {"start": [-1, -1, -1], "end": [1, 1, 1], "default": [0, 0, 0], "names": ["r", "g", "b"]}}], "src": "uniform vec3 STAGE_offsets_x; /// { \"start\": [-1, -1, -1], \"end\": [1, 1, 1], \"default\": [0, 0, 0], \"names\": [\"r\", \"g\", \"b\"] }\nuniform vec3 STAGE_offsets_y; /// { \"start\": [-1, -1, -1], \"end\": [1, 1, 1], \"default\": [0, 0, 0], \"names\": [\"r\", \"g\", \"b\"] }\n\nvec2 STAGE_offset_fix_range(vec2 c) {\n    vec2 res = c;\n    if (res.x > 1.)\n        res.x = res.x - 1.;\n    if (res.x < 0.)\n        res.x = 1. + res.x;\n\n    if (res.y > 1.)\n        res.y = res.y - 1.;\n    if (res.y < 0.)\n        res.y = 1. + res.y;\n\n    return res;\n}\n\nvec4 STAGE(vec2 coords) {\n    vec2 c = coords / u_dimensions;\n\n    vec2 c_r = c + vec2(STAGE_offsets_x.r, STAGE_offsets_y.r);\n    c_r = STAGE_offset_fix_range(c_r);\n    vec2 c_g = c + vec2(STAGE_offsets_x.g, STAGE_offsets_y.g);\n    c_g = STAGE_offset_fix_range(c_g);\n    vec2 c_b = c + vec2(STAGE_offsets_x.b, STAGE_offsets_y.b);\n    c_b = STAGE_offset_fix_range(c_b);\n\n    vec4 color;\n    color.r = INPUT0(c_r * u_tex_dimensions).r;\n    color.g = INPUT0(c_g * u_tex_dimensions).g;\n    color.b = INPUT0(c_b * u_tex_dimensions).b;\n    color.a = 1.;\n    return color;\n}\n"}, "copy_prev_frame": {"inputs": [], "params": [], "src": "vec4 STAGE(vec2 coords) {\n    return vec4(texelFetch(u_prev_frame, ivec2(coords), 0).rgb, 1.);\n}\n"}, "webcam": {"inputs": [], "params": [{"name": "src", "type": null, "info": null}, {"name": "invert_x", "type": "bool", "info": {"default": true}}, {"name": "invert_y", "type": "bool", "info": {"default": true}}], "src": "uniform sampler2D STAGE_src;   /// custom\nuniform bool STAGE_invert_x;   ///  { \"default\": true }\nuniform bool STAGE_invert_y;   ///  { \"default\": true }\n\nvec4 STAGE(vec2 coords) {\n  vec2 c = coords / u_dimensions;\n  if (STAGE_invert_y)\n    c.y = 1. - c.y;\n  if (STAGE_invert_x)\n    c.x = 1. - c.x;\n  c *= vec2(textureSize(STAGE_src, 0));\n\n  return vec4(texelFetch(STAGE_src, ivec2(c), 0).xyz, 1.);\n}\n"}, "rotate": {"inputs": ["INPUT0"], "params": [{"name": "angle", "type": "float", "info": {"start": 0, "end": 6.283185307179586, "default": 0}}], "src": "uniform float STAGE_angle; /// { \"start\": 0, \"end\": \"2 * math.pi\", \"default\": 0 }\n\nvec4 STAGE(vec2 coords) {\n    vec2 c = coords / u_dimensions;\n    c = 2. * c - 1.;\n\n    float r = length(c);\n    float theta = atan(c.y, c.x);\n    theta += STAGE_angle;\n    c = r * vec2(cos(theta), sin(theta));\n\n    c  = (c + 1.) / 2.;\n    c *= u_dimensions;\n\n    return vec4(INPUT0(c).rgb, 1.);\n}\n"}, "zoom": {"inputs": ["INPUT0"], "params": [{"name": "x", "type": "float", "info": {"start": 0, "end": 100, "default": 1}}, {"name": "y", "type": "float", "info": {"start": 0, "end": 100, "default": 1}}, {"name": "center", "type": "vec2", "info": {"start": [0, 0], "end": [1, 1], "default": [0.5, 0.5], "names": ["x", "y"]}}], "src": "uniform float STAGE_x; /// {\"start\": 0, \"end\": 100, \"default\": 1}\nuniform float STAGE_y; /// {\"start\": 0, \"end\": 100, \"default\": 1}\nuniform vec2 STAGE_center; /// {\"start\": [0, 0], \"end\": [1, 1], \"default\": [0.5, 0.5], \"names\": [\"x\", \"y\"]}\n\nvec4 STAGE(vec2 coords) {\n    coords = coords / u_dimensions;\n\n    coords = coords - STAGE_center;\n    if (STAGE_x > 0.)\n      coords.x /= STAGE_x;\n    if (STAGE_y > 0.)\n      coords.y /= STAGE_y;\n    coords += STAGE_center;\n\n    vec2 c = coords * u_tex_dimensions;\n    return vec4(INPUT0(c).xyz, 1.);\n}\n"}}, "template": "#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\nprecision highp int;\n#else\nprecision mediump float;\nprecision mediump int;\n#endif\n\n#define PI 3.1415926538\n#define GOLDEN_RATIO 1.6180339887\n\nuniform vec2 u_dimensions;\nuniform vec2 u_tex_dimensions;\nuniform sampler2D u_prev_frame;\nout vec4 color_out;\n\nvec4 synth(vec2 coords);\n\nvoid main() {\n    vec2 coords = gl_FragCoord.xy;\n    vec2 c = coords * u_tex_dimensions / u_dimensions;\n    color_out = synth(c);\n}\n"}